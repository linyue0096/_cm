## [家庭作業 期中 (猜數字遊戲與流程控制)]
* 完成方法:[使用Gemini](https://gemini.google.com/share/dd37b4471a46)
* 這是利用 Python 實作經典的「終極猜數字」遊戲。遊戲目標是在 $1$ 到 $1000$ 之間猜出一個隨機整數，但程式刻意將嘗試次數限制在 5次 (遠低於二分搜尋法所需的 $\approx 10$ 次)，藉此增加難度並練習迴圈的中斷控制
- 步驟一：定義搜尋空間
遊戲的本質是在一個離散的有限集合 $S$ 中尋找特定元素 $x$
```python
min_num = 1
    max_num = 1000
    # 搜尋空間大小 N = 1000
```
數學定義: 我們的搜尋空間大小 (Search Space Size) 為 $N = \text{max} - \text{min} + 1 = 1000$
目標: 在集合 $S = \{1, 2, ..., 1000\}$ 中找到唯一的解 $A$。

- 步驟二：資訊獲取與空間削減
程式中的核心邏輯在於 elif 與 else 的回饋。

Python
```python
elif guess < answer:
    print("❌ 太小了 (Higher)\n")
                # 實際效果：將搜尋區間 [L, R] 縮減為 [guess+1, R]
else:
    print("❌ 太大了 (Lower)\n")
                # 實際效果：將搜尋區間 [L, R] 縮減為 [L, guess-1]
```
1. 輸入防呆:若使用者輸入文字，int() 轉換會失敗，程式會捕捉 ValueError 並提示錯誤，而不會直接當機。
2. 邏輯保護:只有當輸入是「有效的數字」且「在範圍內」時，attempts_used 才會加 1。這確保了使用者的無心之過不會浪費寶貴的猜測次數。
3. continue的使用:在輸入錯誤時，使用continue直接跳回迴圈開頭，略過後面的比對邏輯。
4. 數學原理:每一次猜測並獲得「太大」或「太小」的回饋，本質上提供了 1 bit (位元) 的資訊量。在最佳策略（二分搜尋法）下，這 1 bit 的資訊可以將搜尋空間 $N$ 削減一半。$$N_{new} \approx \frac{N_{old}}{2}$$

- 步驟三：複雜度分析與不可能定理
這是本作業最重要的數學部分。我們分析為什麼 5 次機會極難猜中。
```python
max_attempts = 5
```
1. 二分搜尋複雜度:要在 $N$ 個有序元素中保證找到目標，最差情況下的步數 $k$ 必須滿足：$$2^k \ge N$$取對數後可得：$$k \ge \lceil \log_2 N \rceil$$
2. 驗證:當 $N = 1000$ 時，理論需要的最小保證次數為：$$k_{min} = \lceil \log_2(1000) \rceil \approx \lceil 9.966 \rceil = 10 \text{ 次}$$
3/ 現狀分析:程式限制 $k=5$。我們能覆蓋的最大區間僅為：$$2^5 = 32$$這表示在 5 次嘗試內，我們只能從 1000 個數字中，有效地過濾出約 32 個數字的範圍。獲勝機率估算:$$P(\text{Win}) \approx \frac{2^5}{1000} = \frac{32}{1000} = 3.2\%$$

- 步驟四：實作結論
先將方程式的領導係數 $a$ 化為 1。若 $a=0$ 則不是三次方程式，需拋出錯誤。
```python
# 3. 使用 while 迴圈，直到次數用完
    while attempts_used < max_attempts:
       # ...
```
* 證明了演算法的一個核心限制：當演算法的時間複雜度需求 ($O(\log N)$) 超過給定的資源限制時，演算法無法保證收斂。 除非運氣極佳（猜測剛好落在 $3.2\%$ 的覆蓋範圍內），否則「遊戲結束」是數學上的必然結果。

